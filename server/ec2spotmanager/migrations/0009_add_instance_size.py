# -*- coding: utf-8 -*-
# Generated by Django 1.11.5 on 2018-07-31 19:49
from __future__ import unicode_literals, print_function
import json
import math
import sys

from django.db import migrations, models

from ec2spotmanager.common.ec2 import CORES_PER_INSTANCE


# return a flattened set of instance types for a given PoolConfiguration
def instance_types_by_poolconfig(cfg):
    instance_types = set()
    while cfg is not None:
        if cfg.ec2_instance_types:
            instance_types |= set(json.loads(cfg.ec2_instance_types))
        cfg = cfg.parent
    return instance_types


def instance_count_to_cores(apps, schema_editor):
    PoolConfiguration = apps.get_model("ec2spotmanager", "PoolConfiguration")
    Instance = apps.get_model("ec2spotmanager", "Instance")

    # given a list of instance types, determine the core count
    def _calculate_core_count(instance_types, log_prefix):
        if not instance_types:
            print(log_prefix + " No instances? Nothing to do...", file=sys.stderr)
            return None

        instance_sizes = {CORES_PER_INSTANCE[instance_type] for instance_type in instance_types}

        # the price/count should be divided by the number of cores per instance... assuming it was homogenous
        # if not, use the average and print a warning
        if len(instance_sizes) == 1:
            size = sum(instance_sizes)
        else:
            size = sum(instance_sizes) / len(instance_sizes)
            print(log_prefix + " Instance sizes are not all equal: %r" % (list(sorted(instance_sizes)),),
                  file=sys.stderr)
            print(" => using the average of: %0.6f" % (size,), file=sys.stderr)

        return size

    # get list of configs with the field
    def _get_fields_to_update(field_name):
        args = {field_name + "__isnull": False}
        for cfg in PoolConfiguration.objects.filter(**args):
            # for each price/count, which configs does it apply to
            to_search = {cfg.pk}
            affected = set()
            while to_search:
                cur = PoolConfiguration.objects.get(pk=to_search.pop())
                affected.add(cur.pk)
                for child in cur.poolconfiguration_set.all():
                    if getattr(child, field_name) is None:
                        to_search.add(child.pk)

            # for each config that a price/count affects, which instance types could be scheduled
            instance_types = set()
            for affected_pk in affected:
                instance_types |= instance_types_by_poolconfig(PoolConfiguration.objects.get(pk=affected_pk))

            size = _calculate_core_count(instance_types, "[PoolConfig %d, %s]" % (cfg.pk, field_name))
            if size is not None:
                yield cfg, size

    # update price
    for cfg, factor in _get_fields_to_update("ec2_max_price"):
        cfg.ec2_max_price = float(cfg.ec2_max_price) / factor
        cfg.save()

    # update size
    for cfg, factor in _get_fields_to_update("size"):
        cfg.size = int(math.ceil(cfg.size * factor))
        cfg.save()

    # now update the instance size to match configurations
    for instance in Instance.objects.all():
        size = _calculate_core_count(instance_types_by_poolconfig(instance.pool.config),
                                     "[Instance %d]" % (instance.pk,))
        # It shouldn't normally be possible for the size to be None, since this instance was created from the assigned
        # PoolConfiguration. It could happen though, if the server is migrated immediately  after the user removed a
        # running instance type from the list.
        if size is not None:
            instance.size = int(math.ceil(size))
            instance.save()


class Migration(migrations.Migration):

    dependencies = [
        ('ec2spotmanager', '0008_remove_aws_creds'),
    ]

    operations = [
        migrations.AddField(
            model_name='instance',
            name='size',
            field=models.IntegerField(default=1),
        ),
        migrations.RunPython(
            code=instance_count_to_cores,
            reverse_code=migrations.RunPython.noop,  # only reversible to support testing
        ),
    ]
